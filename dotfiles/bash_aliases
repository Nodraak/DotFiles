#!/usr/bin/env bash

# export or not export -> http://unix.stackexchange.com/questions/107851/using-export-in-bashrc

#set -u # exit when your script tries to use undeclared variables

# Fix undefined variables
VIRTUAL_ENV_DISABLE_PROMPT=""
VIRTUAL_ENV=""

# depending on OS and version
F=/usr/share/bash-completion/completions/git
if [[ -e "$F" ]]; then source "$F"; fi
F=/etc/bash_completion.d/git-prompt
if [[ -e "$F" ]]; then source "$F"; fi
F=/etc/bash_completion.d/git
if [[ -e "$F" ]]; then source "$F"; fi
# /usr/lib/git-core/git-sh-prompt/git-sh-prompt.sh
# source /usr/share/git-core/contrib/completion/git-prompt.sh


#
# Set title of terminal, used by PS1 and some alias
#

set_xtitle () {
    case "$TERM" in
        *term* | rxvt)
            echo -en "\033]0;$@\007"
            ;;
        *)
            ;;
    esac
}

#
# Color definitions - for fancy prompt PS1 or colored man
#

# Normal Colors
Black='\e[0;30m'
Red='\e[0;31m'
Green='\e[0;32m'
Yellow='\e[0;33m'
Blue='\e[0;34m'
Purple='\e[0;35m'
Cyan='\e[0;36m'
White='\e[0;37m'

# Bold
BBlack='\e[1;30m'
BRed='\e[1;31m'
BGreen='\e[1;32m'
BYellow='\e[1;33m'
BBlue='\e[1;34m'
BPurple='\e[1;35m'
BCyan='\e[1;36m'
BWhite='\e[1;37m'

# Background
On_Black='\e[40m'
On_Red='\e[41m'
On_Green='\e[42m'
On_Yellow='\e[43m'
On_Blue='\e[44m'
On_Purple='\e[45m'
On_Cyan='\e[46m'
On_White='\e[47m'

# Color Reset
NC="\e[m"

#
# Colored man
#

# mb start blink
# md start bold
# me turn off bold, blink and underline
# so start standout (reverse video)
# se stop standout
# us start underline
# ue stop underline

export LESS_TERMCAP_mb=$'\E[0m'
export LESS_TERMCAP_md=$'\E[0;32m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_so=$'\E[0;31m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_us=$'\E[0;34m'
export LESS_TERMCAP_ue=$'\E[0m'

#
# Fancy prompt PS1
#

_ps1_update () {
    local last_cmd_ret="$?"  # must be first

    local tmp
    local user_hostname
    local user_hostname="${USER}@${HOSTNAME}"

    # window title
    #set_xtitle "${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}"

    PS1=""

    # date
    PS1+="${Cyan}\t${NC} "

    # login + hostname
    # TODO: add rpi + update for Debian 9
    if [[ "$user_hostname" = "achardon@ltadch" ]]; then
        PS1+="${Green}$user_hostname${NC} "
    elif [[ "$user_hostname" = "Debian@ltadch" ]]; then
        PS1+="${Green}$user_hostname${NC} "
    elif [[ "$user_hostname" = "adch@s5icsaswdev" ]]; then
        PS1+="${Cyan}$user_hostname${NC} "
    else
        PS1+="${Red}$user_hostname${NC} "
    fi

    # git
    if [[ "$(type -t __git_ps1)" = "" ]]; then
        PS1+="${Red}gitPS1NotFound${NC} "
    else
        tmp="$(__git_ps1 "[%s]")"
        if [[ -n "$tmp" ]]; then
            PS1+="${Yellow}$tmp${NC} "
        fi
    fi

    # last cmd ret
    if [[ "$last_cmd_ret" != "0" ]]; then
        PS1+="${Red}$last_cmd_ret${NC} "
    fi

    # cwd
    PS1+="${Blue}\w${NC} "

    # finally, new line + user/root prompt
    PS1+="\n\\$ "

    # no "export PS1" needed
}

PROMPT_COMMAND="_ps1_update"

export GIT_PS1_SHOWDIRTYSTATE=1
export GIT_PS1_SHOWUPSTREAM="auto verbose git"

#
# Aliases
#

# clipboard
alias pbcopy='xsel --clipboard --input'
alias pbpaste='xsel --clipboard --output'

# basic cmd
alias ls='ls --color'
alias ll='ls -lGh'
alias la='ls -lGha'
alias lla='la'
alias grep='grep --color'
alias pcregrep='pcregrep --color'
alias du='du -kh'
alias df='df -khT'

# more advanced cmd
alias c='clear'
alias py='python3'
alias ipy='ipython3'
alias v="vim"
alias diff='colordiff'
alias vd='vimdiff'

# dev
alias g='git'  # now this is what I call 'lazy'
complete -o default -o nospace -F _git g
alias gg='gitg'
alias gg.='gg .'
alias gcc='gcc -fdiagnostics-color=auto'
alias disas='objdump -D -F -M intel --demangle'
alias disasArm='arm-none-eabi-objdump -D -F -M intel --demangle'

# dev - techno specific utils
#alias pylint='pylint3 --comment=y'
complete -o nospace -F _filedir_xspec pylint
#alias pylintd='pylint3 --load-plugins pylint_django'

# dual monitor
alias dmen='xrandr --output HDMI1 --above LVDS1 --auto'
alias dmdis='xrandr --output HDMI1 --off'

# misc
alias pdflatex='pdflatex -file-line-error -halt-on-error'
HISTIGNORE='jrnl *'  # no export needed
bind Space:magic-space  # expand !!, ^old^new, etc

alias sl='sl -e'
alias tmux='TERM=screen-256color tmux'  # keep vim's user defined theme
alias dmesg='dmesg -dTw'

alias ports='netstat -tulanp'
alias getlyrics='kid3-cli -c "get comment" "$(mocp --info | grep File | cut -b 7-)"'


#
# Env variables
#

export EDITOR="vim"  # for git, crontab, ...

export GOPATH=~/gopath
export PATH=$GOPATH:$GOPATH/bin:${PATH}
export DRIVE_GOMAXPROCS=8

#export GCCARMPATH=/home/nodraak/Documents/Etudes/ECE_ING4/Deoxys/stm32-mbed/gcc-arm-none-eabi-5_4-2016q2/bin
#export PATH=$GCCARMPATH:${PATH}

#export PATH=/opt/node-v8.1.2-linux-x64/bin/:${PATH}

#
# Functions
#

_texspell_file() {
    if [ $# -ne 4 ]
    then
        echo "Usage: _texspell <lang> <file> <extradict> <localdict>"
        return 1
    fi

    lang=$1
    file=$2
    extradict=$3
    localdict=$4

    for word in $(aspell --lang="$lang" --mode=tex "$extradict" "$localdict" list < "$file" | sort | uniq)
    do
        echo "$word"
        #echo "== $word =="
        #grep --with-filename --line-number " $word " "$file"
    done
}

texspell () {
    # args

    if [ $# -ne 2 ]
    then
        echo "Usage: texspell <lang> <file or dir>"
        return 0
    fi

    lang="$1"
    file_or_dir="$2"

    # options

    extradict=""
    localdict=""
    if [ -f "/usr/lib/aspell/custom_${lang}.rws" ]
    then
        echo "Using extra dic \"custom_${lang}.rws\""
        extradict="--extra-dicts=custom_${lang}.rws"
    fi
    if [ -f "./aspell_dict.txt" ]
    then
        echo "Using personal dict \"./aspell_dict.txt\""
        localdict="--personal=./aspell_dict.txt"
    fi

    # now spell checking

    if [ -d "$file_or_dir" ]
    then
        echo "Spell checking all .tex files in folder $file_or_dir"
        for f in $(find "$file_or_dir" | grep "\.tex$")
        do
            _texspell_file "$lang" "$f" "$extradict" "$localdict"
        done
    fi

    if [ -f "$file_or_dir" ]
    then
        echo "Spell checking file $file_or_dir"
        _texspell_file "$lang" "$file_or_dir" "$extradict" "$localdict"
    fi
}

#texdic () {
#    sudo aspell --lang=en create master /usr/lib/aspell/custom_en.rws < ./dic.txt
#}

o () {
    local cmd

    if [[ $# -eq 0 ]]; then
        echo 'Error: argument expected.'
        return 1
    fi

    file -E "$1"
    if [[ $?  -ne 0 ]]; then
        echo 'Error: File not found.'
        return 2
    fi

    cmd=""

    case $1 in
        *.png|*.jpg|*.jpeg )
            cmd="eog"
            ;;
        *.mp3|*.flac|*.mp4|*.mkv|*.avi )
            cmd="vlc"
            ;;
        *.pdf )
            #cmd="evince"
            cmd="zathura"
            ;;
        *.txt|*.md|*.tex|*.c|*.h|*.py|*.css|*.scss|*.js|*.json|*.sh )
            cmd="sublime"
            ;;
        *.html )
            cmd="firefox"
            ;;
        * )
            if [ $# -eq 1 ]; then
                case $1 in
                    *.tar.bz2)  cmd="tar xvjf"      ;;
                    *.tar.gz)   cmd="tar xvzf"      ;;
                    *.bz2)      cmd="bunzip2"       ;;
                    *.rar)      cmd="unrar x"       ;;
                    *.gz)       cmd="gunzip"        ;;
                    *.tar)      cmd="tar xvf"       ;;
                    *.tbz2)     cmd="tar xvjf"      ;;
                    *.tgz)      cmd="tar xvzf"      ;;
                    *.zip)      cmd="unzip"         ;;
                    *.Z)        cmd="uncompress"    ;;
                    *.7z)       cmd="7z x"          ;;
                esac
            fi
            ;;
    esac

    if [[ "$cmd" = "" ]]; then
        echo Error: unknown extension, using pcmanfm for opening "$@"
        cmd="pcmanfm"
    fi

    exec $cmd "$@" &
}
complete -o nospace -F _filedir_xspec o

whereispylib () {
    for lib in "$@"
    do
        python3 -c "
try:
    import $lib
    try:
        if len($lib.__path__) == 1:
            print($lib.__path__[0])
        else:
            print($lib.__path__)
    except AttributeError:
        print('$lib is a built-in module')
except ImportError:
    print('$lib is not installed')
"

    done
}

prettyjson() {
    python -m json.tool "$@" | pygmentize -l javascript
}

grepdf () {
    if [ $# -ne 2 ] && [ $# -ne 3 ]; then
        echo "Usage: grepdf <pattern> <path> [<grep opt>]"
        return 0
    fi

    pattern=$1
    path=$2
    grepopt=""
    if [ $# -eq 3 ]; then
        grepopt=$3
    fi

    find_cmd="pdftotext -q '{}' - | grep $grepopt --with-filename --label='{}' --color \"$pattern\""
    find "$path" -name "*.pdf" -exec sh -c "$find_cmd" \;
}

pdf_extract_page() {
    if [ $# -ne 4 ]
    then
        echo "usage: ./script infile outfile start stop"
        return 1
    fi

    INFILE=$1
    OUTFILE=$2
    START=$3
    STOP=$4

    gs -sDEVICE=pdfwrite -dNOPAUSE -dSAFER -dFirstPage="$START" -dLastPage="$STOP" -sOutputFile="$OUTFILE" "$INFILE"
}

airdroid_proxy () {
    mitmproxy -s test_mtimproxy.py -R https://192.168.87.101:8890/ -b 127.0.0.1 -p 8080
}


#
# Tmp / unused stuff (to be deleted at the end of the year)
#

how_to_screengif () {
    echo "gtk-recordmydesktop"
    echo "mplayer -ao null <VIDEO> -vo jpeg:outdir=output"
    echo "convert output/* output.gif"
    echo ""
    echo "convert output.gif -fuzz 10% -layers Optimize optimised.gif"
    echo "gifsicle -O in.gif -o out.gif"
}

alias youtube-dl-audio="youtube-dl --extract-audio --format 140"


_swapusage() {
    for file in /proc/*/status
    do
        NAME="$(awk '/^Name:/{printf $2}' $file)"
        PID="$(awk '/^Pid:/{printf $2}' $file)"
        SWAP="$(awk '/^VmSwap:/{printf $2}' $file)"

        if [[ -n "${SWAP}" ]] && [[ "${SWAP}" != "0" ]]
        then
            echo "${NAME} ${PID} ${SWAP}"
        fi
    done
}

swapusage() {
    echo "Name             Pid    Swap"
    _swapusage | column -t | sort -k 3 -n
    echo "Name             Pid    Swap"
}

# docker X11 forwarding
#xhost +local:nodraak > /dev/null

#
# GMV
#

# ltadch

function setup_aliases_ltadch() {
    # from http://wpad/wpad.dat - 2019-05-07
    export http_proxy="http://ptmproxy.gmv.es:80"
    export https_proxy="http://ptmproxy.gmv.es:80"

    alias mount_projects="sudo umount /mnt/p ; sudo mount -t drvfs '\\\\gmvprojects\\s5_ics_asw' /mnt/p"
    alias mount_gmvstorage="sudo umount /mnt/s ; sudo mount -t drvfs '\\\\gmvstorage\\storage\\S5-ICS-ASW' /mnt/s"
    alias mount_gmvteca="sudo umount /mnt/t ; sudo mount -t drvfs '\\\\gmvteca\\gmvteca' /mnt/t"

    export DISPLAY=localhost:0.0
    alias xforwardS5Vcast="ssh -fX s5dev vcastqt"
    alias checkPis="ssh s5pis 'ps aux | grep h1505-mib'"

    alias sudo='sudo -EH'
}

# s5icsaswdev

function setup_path_ut_vcast() {
    export PATH=$PATHUNITEST
}

function setup_path_vt() {
    export PATH=$PATHVALTEST
}

function setup_aliases_s5dev() {

    #
    # PATH
    #

    export PATHBAK=$PATH

    # common
    export PATH=$PATH:/home/adch/scripts
    export PATH=$PATH:/opt/vcast
    export PATH=$PATH:/opt/tsim-leon/tsim/linux-x64

    # custom
    export PATHUNITEST=$PATH:/opt/rtems-4.6/bin/
    export PATHVALTEST=$PATH:/opt/rtems/4.6_20171003/bin

    #setup_path_ut_vcast
    setup_path_vt

    #
    # Others
    #

    export LM_LICENSE_FILE=41931@licserver
    export S5ICSASW_VCAST_CONFIG_DIR=~/S5-ICS-ASW-VectorCast_CONFIG/

    alias svnstatus='svn status | grep -v ?'
    alias py='python3.6'
    alias pylint='python3.6 -m pylint'

    export LC_ALL=en_US.utf8
    export LC_CTYPE=en_US.utf8
}


setup_aliases_ltadch
#setup_aliases_s5dev

